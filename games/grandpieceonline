-- Umbrella Hub FULL
local UI_LIB_URL = 'https://github.com/Atom1gg/pizda/raw/refs/heads/main/1.lua'
local UmbrellaHub = loadstring(game:HttpGet(UI_LIB_URL))()
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ================================
-- SAFE MODULE
-- ================================
local SafeModule = {
    enabled = false,
    speedDetectionBypass = false,
    walkSpeedBypass = false,
    abilityProtection = false,
    waitHook = false
}

local function SetupSpeedDetectionBypass()
    pcall(function()
        local mt = getrawmetatable(game)
        setreadonly(mt,false)
        local oldNamecall = mt.__namecall
        mt.__namecall = newcclosure(function(self,...)
            local method = getnamecallmethod()
            local args = {...}
            if method=="FireServer" and args[1]==10 then
                print("üõ°Ô∏è Blocked speed detection FireServer")
                return 1
            end
            return oldNamecall(self,...)
        end)
        setreadonly(mt,true)
        SafeModule.speedDetectionBypass=true
    end)
end

local function SetupWalkSpeedBypass()
    pcall(function()
        local mt = getrawmetatable(game)
        setreadonly(mt,false)
        local oldIndex = mt.__index
        mt.__index = newcclosure(function(self,key)
            if key=="WalkSpeed" and self:IsA("Humanoid") then return 16 end
            return oldIndex(self,key)
        end)
        setreadonly(mt,true)
        SafeModule.walkSpeedBypass=true
    end)
end

local function SetupAbilityProtection()
    pcall(function()
        local mt = getrawmetatable(game)
        setreadonly(mt,false)
        local oldNamecall = mt.__namecall
        mt.__namecall = newcclosure(function(self,...)
            local method = getnamecallmethod()
            local args = {...}
            if method=="InvokeServer" and (args[1]=="Soru" or args[1]=="Geppo") then
                wait(0.2)
                print("üõ°Ô∏è Protected ability:", args[1])
            end
            return oldNamecall(self,...)
        end)
        setreadonly(mt,true)
        SafeModule.abilityProtection=true
    end)
end

local function SetupWaitHook()
    pcall(function()
        local originalWait=wait
        getgenv().wait=function(time)
            if SafeModule.waitHook then return originalWait(math.max(time or 0,0.1)) end
            return originalWait(time)
        end
        SafeModule.waitHook=true
    end)
end

local function toggleSafeMode(state)
    SafeModule.enabled=state
    if state then
        SetupSpeedDetectionBypass()
        SetupWalkSpeedBypass()
        SetupAbilityProtection()
        SetupWaitHook()
        print("üõ°Ô∏è Safe Mode activated")
    else
        print("üî¥ Safe Mode deactivated")
    end
end

--- ================================
-- WALK SPEED MODULE (BV Speed)
-- ================================
local WalkspeedModule = {
    Enabled = false,
    Speed = 16,
    BV = nil
}

local function SetupBV()
    if not LocalPlayer.Character then return end
    local hrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if hrp and not WalkspeedModule.BV then
        WalkspeedModule.BV = Instance.new("BodyVelocity", hrp)
        WalkspeedModule.BV.MaxForce = Vector3.new(9e9,0,9e9)
    end
end

local bvConnection
local function UpdateBV()
    if not WalkspeedModule.BV or not LocalPlayer.Character then return end
    local hum = LocalPlayer.Character:FindFirstChild("Humanoid")
    if hum then
        WalkspeedModule.BV.Velocity = hum.MoveDirection * WalkspeedModule.Speed
    end
end

local function ToggleWalkspeed(state)
    WalkspeedModule.Enabled = state
    if state then
        SetupBV()
        if bvConnection then bvConnection:Disconnect() end
        bvConnection = RunService.RenderStepped:Connect(UpdateBV)
    else
        if bvConnection then bvConnection:Disconnect() bvConnection = nil end
        if WalkspeedModule.BV then WalkspeedModule.BV:Destroy() WalkspeedModule.BV = nil end
    end
end

-- ================================
-- CHEST ESP MODULE (–¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏—é World)
-- ================================
local ChestESP = {
    Enabled = false,
    ShowDistance = true,
    MaxDistance = 500,
    UpdateRate = 0.0001,
    BaseTextSize = 14,
    MinScale = 0.3,
    MaxScale = 2.5
}

local chestDrawings = {}
local chestData = {}
local colorStats = {}
local lastUpdateTime = 0
local effects = workspace:FindFirstChild("Effects")

local function CreateDrawing(type, props)
    local d = Drawing.new(type)
    for k, v in pairs(props) do d[k] = v end
    return d
end

local function LogChestColor(originalColor, chestType)
    local r, g, b = originalColor.R, originalColor.G, originalColor.B
    local colorKey = string.format("%.6f_%.6f_%.6f", r, g, b)
    
    if not colorStats[colorKey] then
        colorStats[colorKey] = {
            color = originalColor,
            type = chestType,
            count = 0
        }
    end
    
    colorStats[colorKey].count = colorStats[colorKey].count + 1
    
    print(string.format("Chest Color: %s | R:%.6f G:%.6f B:%.6f | Total: %d", 
        chestType, r, g, b, colorStats[colorKey].count))
end

local function ColorMatch(r1, g1, b1, r2, g2, b2, tolerance)
    tolerance = tolerance or 0.001
    return math.abs(r1 - r2) < tolerance and 
           math.abs(g1 - g2) < tolerance and 
           math.abs(b1 - b2) < tolerance
end

local function GetChestColorName(originalColor)
    local r, g, b = originalColor.R, originalColor.G, originalColor.B
    local chestType, espColor
    
    if ColorMatch(r, g, b, 0, 0, 0) then
        chestType = "LEGENDARY"
        espColor = Color3.fromRGB(255, 215, 0)
        return espColor, chestType
    end
    
    if ColorMatch(r, g, b, 0.639216, 0.635294, 0.647059) then
        chestType = "RARE"
        espColor = Color3.fromRGB(0, 162, 255)
    elseif ColorMatch(r, g, b, 1, 0.705882, 0.898039) then
        chestType = "MYTHIC"
        espColor = Color3.fromRGB(138, 43, 226)
    elseif ColorMatch(r, g, b, 0.423529, 0.345098, 0.294118) then
        chestType = "COMMON"
        espColor = Color3.fromRGB(139, 69, 19)
    elseif ColorMatch(r, g, b, 0.388235, 0.372549, 0.384313) then
        chestType = "UNCOMMON"
        espColor = Color3.fromRGB(192, 192, 192)
    elseif ColorMatch(r, g, b, 0.388235, 0.372549, 0.384314) then
        chestType = "UNCOMMON_2"
        espColor = Color3.fromRGB(160, 160, 160)
    else
        chestType = "UNKNOWN"
        espColor = Color3.fromRGB(255, 215, 0)
    end
    
    LogChestColor(originalColor, chestType)
    return espColor, chestType
end

local function GetPlayerPosition()
    local character = LocalPlayer and LocalPlayer.Character
    if not character then return nil end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    return humanoidRootPart and humanoidRootPart.Position
end

local function GetDistance(pos1, pos2)
    return (pos1 - pos2).Magnitude
end

local function GetDistanceScale(distance)
    local scale = math.clamp(distance / 50, ChestESP.MinScale, ChestESP.MaxScale)
    return scale
end

local function GetChestScreenPosition(meshPart)
    local worldPos = meshPart.Position
    local screenPos, visible = Camera:WorldToViewportPoint(worldPos)
    
    if visible and screenPos.Z > 0 then
        return Vector2.new(screenPos.X, screenPos.Y), true
    end
    
    return nil, false
end

local function CreateChestESP(meshPart, groupName)
    local espColor, chestType = GetChestColorName(meshPart.Color)
    local chestId = groupName
    
    chestData[chestId] = {
        MeshPart = meshPart, 
        Type = chestType, 
        Color = espColor,
        LastUpdate = 0
    }
    
    chestDrawings[chestId] = {
        Text = CreateDrawing("Text", {
            Size = ChestESP.BaseTextSize, 
            Color = espColor, 
            Outline = true, 
            OutlineColor = Color3.new(0, 0, 0), 
            Center = true
        })
    }
end

local function RemoveChestESP(chestId)
    if chestDrawings[chestId] then
        for _, drawing in pairs(chestDrawings[chestId]) do 
            drawing:Remove() 
        end
        chestDrawings[chestId] = nil
    end
    chestData[chestId] = nil
end

local function UpdateChestESP()
    local currentTime = tick()
    if currentTime - lastUpdateTime < ChestESP.UpdateRate then return end
    lastUpdateTime = currentTime
    
    if not ChestESP.Enabled or not effects then return end
    
    local playerPos = GetPlayerPosition()
    if not playerPos then return end
    
    local toRemove = {}
    
    for chestId, drawings in pairs(chestDrawings) do
        local data = chestData[chestId]
        
        if not data or not data.MeshPart or not data.MeshPart.Parent then
            table.insert(toRemove, chestId)
            continue
        end
        
        local meshPart = data.MeshPart
        local distance = GetDistance(playerPos, meshPart.Position)
        
        if distance > ChestESP.MaxDistance then
            for _, drawing in pairs(drawings) do 
                drawing.Visible = false 
            end
            continue
        end
        
        local screenPos, visible = GetChestScreenPosition(meshPart)
        
        if not visible then
            for _, drawing in pairs(drawings) do 
                drawing.Visible = false 
            end
            continue
        end
        
        local scale = GetDistanceScale(distance)
        local textSize = math.max(10, math.floor(ChestESP.BaseTextSize * scale))
        
        drawings.Text.Text = ChestESP.ShowDistance and 
            string.format("%s [%dm]", data.Type, math.floor(distance)) or 
            data.Type
        drawings.Text.Size = textSize
        drawings.Text.Position = Vector2.new(screenPos.X, screenPos.Y)
        drawings.Text.Visible = ChestESP.Enabled
        drawings.Text.Color = data.Color
    end
    
    for _, chestId in ipairs(toRemove) do
        RemoveChestESP(chestId)
    end
end

local function FindNewChests()
    if not effects then return end
    
    for _, group in pairs(effects:GetChildren()) do
        if (group:IsA("Model") or group:IsA("Group")) and not chestData[group.Name] then
            local meshPart = group:FindFirstChildOfClass("MeshPart")
            if meshPart then
                local prompt = meshPart:FindFirstChildOfClass("ProximityPrompt")
                if prompt then
                    CreateChestESP(meshPart, group.Name)
                end
            end
        end
    end
end

local function ToggleChestESP(state)
    ChestESP.Enabled = state
    if state then
        print("üì¶ Chest ESP –≤–∫–ª—é—á–µ–Ω")
    else
        for chestId, drawings in pairs(chestDrawings) do
            for _, drawing in pairs(drawings) do 
                drawing.Visible = false 
            end
        end
        print("üì¶ Chest ESP –≤—ã–∫–ª—é—á–µ–Ω")
    end
end

-- –ó–∞–ø—É—Å–∫–∞–µ–º —Ü–∏–∫–ª—ã
spawn(function()
    while true do
        if ChestESP.Enabled and effects then
            FindNewChests()
        end
        wait(1)
    end
end)

RunService.Heartbeat:Connect(UpdateChestESP)

-- ================================
-- JUMP BOOST MODULE
-- ================================
local JumpBoostModule = {
    Enabled = false,
    Power = 50
}

RunService.RenderStepped:Connect(function()
    if JumpBoostModule.Enabled and LocalPlayer.Character then
        local hum = LocalPlayer.Character:FindFirstChild("Humanoid")
        if hum then hum.JumpPower = JumpBoostModule.Power end
    end
end)

-- ================================
-- INFINITY JUMP MODULE
-- ================================
local InfinityJumpModule = {
    Enabled = false
}

UserInputService.JumpRequest:Connect(function()
    if InfinityJumpModule.Enabled and LocalPlayer.Character then
        local hum = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if hum then hum:ChangeState(Enum.HumanoidStateType.Jumping) end
    end
end)

-- ================================
-- –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô ESP MODULE –° –ù–û–í–´–ú–ò –§–ò–ß–ê–ú–ò
-- ================================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local ESP = {
    Enabled = false,
    ShowPlayers = true,
    ShowFruits = true,
    ShowName = true,
    ShowHealthBar = true,
    ShowPlayerBox = true, -- –ù–û–í–û–ï: –∂–µ–ª—Ç—ã–π –∫–≤–∞–¥—Ä–∞—Ç —É –∏–≥—Ä–æ–∫–∞
    Thickness = 1
}

local drawings = {}
local playerConnections = {}

-- –¶–≤–µ—Ç–∞ –ø–æ rarity
local FruitRarityColors = {
    ["Common"] = Color3.fromRGB(255,255,255),
    ["Rare"] = Color3.fromRGB(173,216,230),
    ["Epic"] = Color3.fromRGB(176,196,222),
    ["Legendary"] = Color3.fromRGB(255,255,0),
    ["Mythical"] = Color3.fromRGB(216,191,216)
}

local Fruits = {
    ["Kilo-Kilo"]="Common",["Suke-Suke"]="Common",["Guru-Guru"]="Common",["Chiyu-Chiyu"]="Common",
    ["Bari-Bari"]="Rare",["Mero-Mero"]="Rare",["Horo-Horo"]="Rare",["Gomu-Gomu"]="Rare",["Bomu-Bomu"]="Rare",
    ["Yomi-Yomi"]="Epic",["Bane-Bane"]="Epic",["Kira-Kira"]="Epic",
    ["Zushi-Zushi"]="Legendary",["Gura-Gura"]="Legendary",["Suna-Suna"]="Legendary",["Hie-Hie"]="Legendary",
    ["Ito-Ito"]="Legendary",["Goro-Goro"]="Legendary",["Nikyu-Nikyu"]="Legendary",["Paw-Paw"]="Legendary",
    ["Mera-Mera"]="Legendary",["Kage-Kage"]="Legendary",["Magu-Magu"]="Legendary",["Pika-Pika"]="Legendary",
    ["Yami-Yami"]="Legendary",["Yuki-Yuki"]="Legendary",["Goru-Goru"]="Legendary",["Moku-Moku"]="Legendary",
    ["Tori-Tori"]="Mythical",["Mochi-Mochi"]="Mythical",["Ope-Ope"]="Mythical",["Doku-Doku"]="Mythical",
    ["Venom-Venom"]="Mythical",["Hito-Hito"]="Mythical",["Buddha-Buddha"]="Mythical",["Ryu-Ryu"]="Mythical",
    ["Pteranodon-Pteranodon"]="Mythical"
}

local R15_BONES={{"UpperTorso","LowerTorso"},{"UpperTorso","LeftUpperArm"},{"UpperTorso","RightUpperArm"},{"LeftUpperArm","LeftLowerArm"},{"LeftLowerArm","LeftHand"},{"RightUpperArm","RightLowerArm"},{"RightLowerArm","RightHand"},{"LowerTorso","LeftUpperLeg"},{"LowerTorso","RightUpperLeg"},{"LeftUpperLeg","LeftLowerLeg"},{"LeftLowerLeg","LeftFoot"},{"RightUpperLeg","RightLowerLeg"},{"RightLowerLeg","RightFoot"}}
local R6_BONES={{"Torso","Left Arm"},{"Torso","Right Arm"},{"Torso","Left Leg"},{"Torso","Right Leg"}}

local function CreateDrawing(type,props)
    local d = Drawing.new(type)
    for k,v in pairs(props) do d[k]=v end
    return d
end

local function GetRigType(character)
    local hum = character:FindFirstChildOfClass("Humanoid")
    if hum then return hum.RigType end
    return character:FindFirstChild("UpperTorso") and Enum.HumanoidRigType.R15 or Enum.HumanoidRigType.R6
end

local function GetPlayerHealth(character)
    local hum = character:FindFirstChildOfClass("Humanoid")
    if hum then return hum.Health, hum.MaxHealth end
    return 0,100
end

local function CleanPlayerDrawings(playerName)
    for key, drawing in pairs(drawings) do
        if string.find(key, playerName) then
            drawing:Remove()
            drawings[key] = nil
        end
    end
end

local function GetPlayerFruits(player)
    local fruits = {}
    local backpack = player:FindFirstChild("Backpack")
    if backpack then
        for fruitName, rarity in pairs(Fruits) do
            local fruit = backpack:FindFirstChild(fruitName)
            if fruit then
                table.insert(fruits, {name = fruitName, rarity = rarity})
            end
        end
    end
    if player.Character then
        for fruitName, rarity in pairs(Fruits) do
            local fruit = player.Character:FindFirstChild(fruitName)
            if fruit then
                table.insert(fruits, {name = fruitName .. " (E)", rarity = rarity})
            end
        end
    end
    return fruits
end

-- –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø: –ü–æ–ª—É—á–µ–Ω–∏–µ bounding box –¥–ª—è –∏–≥—Ä–æ–∫–∞
local function GetPlayerBoundingBox(character)
    local parts = {}
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            table.insert(parts, part)
        end
    end
    
    if #parts == 0 then return nil end
    
    local minX, minY, minZ = math.huge, math.huge, math.huge
    local maxX, maxY, maxZ = -math.huge, -math.huge, -math.huge
    
    for _, part in pairs(parts) do
        local cf = part.CFrame
        local size = part.Size / 2
        
        local corners = {
            cf * Vector3.new(size.X, size.Y, size.Z),
            cf * Vector3.new(-size.X, size.Y, size.Z),
            cf * Vector3.new(size.X, -size.Y, size.Z),
            cf * Vector3.new(size.X, size.Y, -size.Z),
            cf * Vector3.new(-size.X, -size.Y, size.Z),
            cf * Vector3.new(-size.X, size.Y, -size.Z),
            cf * Vector3.new(size.X, -size.Y, -size.Z),
            cf * Vector3.new(-size.X, -size.Y, -size.Z)
        }
        
        for _, corner in pairs(corners) do
            minX = math.min(minX, corner.X)
            minY = math.min(minY, corner.Y)
            minZ = math.min(minZ, corner.Z)
            maxX = math.max(maxX, corner.X)
            maxY = math.max(maxY, corner.Y)
            maxZ = math.max(maxZ, corner.Z)
        end
    end
    
    local center = Vector3.new((minX + maxX) / 2, (minY + maxY) / 2, (minZ + maxZ) / 2)
    local size = Vector3.new(maxX - minX, maxY - minY, maxZ - minZ)
    
    return center, size
end

local function UpdateESP()
    for _, d in pairs(drawings) do d.Visible = false end
    if not ESP.Enabled then return end

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local char = player.Character
            local head = char:FindFirstChild("Head")
            local hrp = char:FindFirstChild("HumanoidRootPart")
            
            if not head or not hrp then continue end
            
            local headPos, headVisible = Camera:WorldToViewportPoint(head.Position)
            if not headVisible or headPos.Z <= 0 then continue end

            local rig = GetRigType(char)
            local skeletonColor = Color3.fromRGB(255, 255, 0)
            local yOffset = -45 -- –ü–û–î–ù–ò–ú–ê–ï–ú –ù–ò–ö –í–´–®–ï

            -- –ù–û–í–û–ï: –ñ–µ–ª—Ç—ã–π –∫–≤–∞–¥—Ä–∞—Ç –≤–æ–∫—Ä—É–≥ –∏–≥—Ä–æ–∫–∞
            if ESP.ShowPlayerBox then
                local center, size = GetPlayerBoundingBox(char)
                if center then
                    local centerPos, centerVisible = Camera:WorldToViewportPoint(center)
                    if centerVisible and centerPos.Z > 0 then
                        -- –ü–æ–ª—É—á–∞–µ–º —É–≥–ª—ã bounding box
                        local corners = {
                            Camera:WorldToViewportPoint(center + Vector3.new(size.X/2, size.Y/2, size.Z/2)),
                            Camera:WorldToViewportPoint(center + Vector3.new(-size.X/2, size.Y/2, size.Z/2)),
                            Camera:WorldToViewportPoint(center + Vector3.new(size.X/2, -size.Y/2, size.Z/2)),
                            Camera:WorldToViewportPoint(center + Vector3.new(size.X/2, size.Y/2, -size.Z/2)),
                            Camera:WorldToViewportPoint(center + Vector3.new(-size.X/2, -size.Y/2, size.Z/2)),
                            Camera:WorldToViewportPoint(center + Vector3.new(-size.X/2, size.Y/2, -size.Z/2)),
                            Camera:WorldToViewportPoint(center + Vector3.new(size.X/2, -size.Y/2, -size.Z/2)),
                            Camera:WorldToViewportPoint(center + Vector3.new(-size.X/2, -size.Y/2, -size.Z/2))
                        }
                        
                        -- –†–∏—Å—É–µ–º –∫–æ–Ω—Ç—É—Ä bounding box
                        for i = 1, 12 do
                            local key = player.Name .. "_box_" .. i
                            if not drawings[key] then
                                drawings[key] = CreateDrawing("Line", {
                                    Thickness = 2,
                                    Color = Color3.fromRGB(255, 255, 0),
                                    Visible = false
                                })
                            end
                            -- –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ –∫—É–±–∞ (–º–æ–∂–Ω–æ –¥–æ—Ä–∞–±–æ—Ç–∞—Ç—å)
                            if i == 1 then
                                drawings[key].From = Vector2.new(corners[1].X, corners[1].Y)
                                drawings[key].To = Vector2.new(corners[2].X, corners[2].Y)
                            elseif i == 2 then
                                drawings[key].From = Vector2.new(corners[1].X, corners[1].Y)
                                drawings[key].To = Vector2.new(corners[3].X, corners[3].Y)
                            end
                            drawings[key].Visible = true
                        end
                    end
                end
            end

            -- Skeleton ESP
            if ESP.ShowPlayers then
                local bones = (rig == Enum.HumanoidRigType.R15) and R15_BONES or R6_BONES
                for _, pair in ipairs(bones) do
                    local p1 = char:FindFirstChild(pair[1])
                    local p2 = char:FindFirstChild(pair[2])
                    if p1 and p2 then
                        local key = player.Name .. "_bone_" .. pair[1] .. pair[2]
                        if not drawings[key] then
                            drawings[key] = CreateDrawing("Line", {
                                Thickness = ESP.Thickness,
                                Color = skeletonColor,
                                Visible = false
                            })
                        end
                        local pos1, on1 = Camera:WorldToViewportPoint(p1.Position)
                        local pos2, on2 = Camera:WorldToViewportPoint(p2.Position)
                        if on1 and on2 and pos1.Z > 0 and pos2.Z > 0 then
                            drawings[key].From = Vector2.new(pos1.X, pos1.Y)
                            drawings[key].To = Vector2.new(pos2.X, pos2.Y)
                            drawings[key].Visible = true
                        end
                    end
                end
            end

            -- Name ESP (–ü–û–î–ù–Ø–¢ –í–´–®–ï)
            if ESP.ShowName then
                local key = player.Name .. "_name"
                if not drawings[key] then
                    drawings[key] = CreateDrawing("Text", {
                        Text = player.Name,
                        Size = 18, -- –£–í–ï–õ–ò–ß–ò–õ–ò –ù–ê 6 –ü–ò–ö–°–ï–õ–ï–ô
                        Color = skeletonColor,
                        Center = true,
                        Outline = true,
                        OutlineColor = Color3.fromRGB(0, 0, 0),
                        Visible = false
                    })
                end
                drawings[key].Position = Vector2.new(headPos.X, headPos.Y + yOffset)
                drawings[key].Visible = true
                yOffset = yOffset - 22
            end

            -- –§—Ä—É–∫—Ç—ã ESP
            if ESP.ShowFruits then
                local fruits = GetPlayerFruits(player)
                for i, fruitData in ipairs(fruits) do
                    local key = player.Name .. "_fruit_" .. i
                    if not drawings[key] then
                        drawings[key] = CreateDrawing("Text", {
                            Size = 16, -- –£–í–ï–õ–ò–ß–ò–õ–ò –†–ê–ó–ú–ï–†
                            Center = true,
                            Outline = true,
                            OutlineColor = Color3.fromRGB(0, 0, 0),
                            Visible = false
                        })
                    end
                    drawings[key].Text = fruitData.name
                    drawings[key].Color = FruitRarityColors[fruitData.rarity]
                    drawings[key].Position = Vector2.new(headPos.X, headPos.Y + yOffset)
                    drawings[key].Visible = true
                    yOffset = yOffset - 20
                end
            end

            -- Health Bar ESP (–ü–ï–†–ï–ú–ï–©–ê–ï–ú –ü–û–î –ò–ì–†–û–ö–ê)
            if ESP.ShowHealthBar then
                local cur, max = GetPlayerHealth(char)
                local pct = math.clamp(cur / max, 0, 1)
                
                -- Background (–ü–û–î –ò–ì–†–û–ö–û–ú)
                local bgKey = player.Name .. "_hp_bg"
                if not drawings[bgKey] then 
                    drawings[bgKey] = CreateDrawing("Line", {
                        Thickness = 6,
                        Color = Color3.fromRGB(50, 50, 50),
                        Visible = false
                    })
                end
                drawings[bgKey].From = Vector2.new(headPos.X - 35, headPos.Y + 60) -- –ü–û–î –ò–ì–†–û–ö–û–ú
                drawings[bgKey].To = Vector2.new(headPos.X - 35, headPos.Y + 120) -- –ü–û–î –ò–ì–†–û–ö–û–ú
                drawings[bgKey].Visible = true

                -- Health Fill (–ü–û–î –ò–ì–†–û–ö–û–ú)
                local fillKey = player.Name .. "_hp_fill"
                if not drawings[fillKey] then 
                    drawings[fillKey] = CreateDrawing("Line", {
                        Thickness = 3,
                        Visible = false
                    })
                end
                drawings[fillKey].From = Vector2.new(headPos.X - 35, headPos.Y + 120) -- –ü–û–î –ò–ì–†–û–ö–û–ú
                drawings[fillKey].To = Vector2.new(headPos.X - 35, headPos.Y + 120 - 60 * pct) -- –ü–û–î –ò–ì–†–û–ö–û–ú
                drawings[fillKey].Color = Color3.fromRGB(255 * (1 - pct), 255 * pct, 0)
                drawings[fillKey].Visible = true

                -- Health Text (–ü–û–î –ò–ì–†–û–ö–û–ú)
                local hpTextKey = player.Name .. "_hp_text"
                if not drawings[hpTextKey] then 
                    drawings[hpTextKey] = CreateDrawing("Text", {
                        Size = 14,
                        Color = Color3.fromRGB(255, 255, 255),
                        Center = true,
                        Outline = true,
                        OutlineColor = Color3.fromRGB(0, 0, 0),
                        Visible = false
                    })
                end
                drawings[hpTextKey].Text = string.format("%d/%d", math.floor(cur), math.floor(max))
                drawings[hpTextKey].Position = Vector2.new(headPos.X - 50, headPos.Y + 75) -- –ü–û–î –ò–ì–†–û–ö–û–ú
                drawings[hpTextKey].Visible = true
            end
        end
    end
end

-- –û—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π...
local function SetupPlayerEvents()
    Players.PlayerRemoving:Connect(function(player)
        CleanPlayerDrawings(player.Name)
        if playerConnections[player] then
            for _, connection in pairs(playerConnections[player]) do
                connection:Disconnect()
            end
            playerConnections[player] = nil
        end
    end)
    
    Players.PlayerAdded:Connect(function(player)
        playerConnections[player] = {}
        local function onCharacterAdded(character)
            wait(1)
            CleanPlayerDrawings(player.Name)
        end
        
        if player.Character then
            onCharacterAdded(player.Character)
        end
        
        table.insert(playerConnections[player], player.CharacterAdded:Connect(onCharacterAdded))
    end)
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and not playerConnections[player] then
            playerConnections[player] = {}
            local function onCharacterAdded(character)
                wait(1)
                CleanPlayerDrawings(player.Name)
            end
            
            if player.Character then
                onCharacterAdded(player.Character)
            end
            
            table.insert(playerConnections[player], player.CharacterAdded:Connect(onCharacterAdded))
        end
    end
end

local espConnection
function toggleESP(state)
    ESP.Enabled = state
    if state then
        SetupPlayerEvents()
        if espConnection then espConnection:Disconnect() end
        espConnection = RunService.RenderStepped:Connect(UpdateESP)
        print("üîç ESP –≤–∫–ª—é—á–µ–Ω")
    else
        if espConnection then 
            espConnection:Disconnect() 
            espConnection = nil 
        end
        
        for player, connections in pairs(playerConnections) do
            for _, connection in pairs(connections) do
                connection:Disconnect()
            end
        end
        playerConnections = {}
        
        for _, d in pairs(drawings) do d:Remove() end
        drawings = {}
        print("üîç ESP –≤—ã–∫–ª—é—á–µ–Ω")
    end
end

return {
    toggle = toggleESP,
    settings = ESP
}

-- ================================
-- SIMPLE NOCLIP MODULE
-- ================================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local NoClipModule = {
    Enabled = false,
    Connection = nil
}

local function NoClipLoop()
    if not LocalPlayer.Character then return end
    
    -- –ü—Ä–æ—Å—Ç–æ –æ—Ç–∫–ª—é—á–∞–µ–º –∫–æ–ª–ª–∏–∑–∏—é –≤—Å–µ—Ö —á–∞—Å—Ç–µ–π –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
    for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            part.CanCollide = false
        end
    end
end

local function ToggleNoClip(state)
    NoClipModule.Enabled = state
    
    if state then
        -- –í–∫–ª—é—á–∞–µ–º
        if NoClipModule.Connection then NoClipModule.Connection:Disconnect() end
        NoClipModule.Connection = RunService.Stepped:Connect(NoClipLoop)
        print("üëª NoClip ON")
    else
        -- –í—ã–∫–ª—é—á–∞–µ–º
        if NoClipModule.Connection then 
            NoClipModule.Connection:Disconnect() 
            NoClipModule.Connection = nil 
        end
        
        -- –í–∫–ª—é—á–∞–µ–º –∫–æ–ª–ª–∏–∑–∏—é –æ–±—Ä–∞—Ç–Ω–æ
        if LocalPlayer.Character then
            for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                    part.CanCollide = true
                end
            end
        end
    end
end

-- –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–º–µ–Ω—ã –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
LocalPlayer.CharacterAdded:Connect(function()
    wait(1) -- –ñ–¥–µ–º –∑–∞–≥—Ä—É–∑–∫–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
    if NoClipModule.Enabled then
        -- –ï—Å–ª–∏ –Ω–æ—É–∫–ª–∏–ø –±—ã–ª –≤–∫–ª—é—á–µ–Ω, –≤–∫–ª—é—á–∞–µ–º –µ–≥–æ —Å–Ω–æ–≤–∞
        ToggleNoClip(true)
    end
end)

-- ================================
-- REGISTER MODULES
-- ================================
UmbrellaHub.api:registerModule("Server",{name="Safe Mode",enabled=false,callback=toggleSafeMode})
UmbrellaHub.api:registerModule("Player",{name="Walkspeed",enabled=false,callback=ToggleWalkspeed})
UmbrellaHub.api:registerModule("Player",{name="Jump Boost",enabled=false,callback=function(state) JumpBoostModule.Enabled=state end})
UmbrellaHub.api:registerModule("Player",{name="Infinity Jump",enabled=false,callback=function(state) InfinityJumpModule.Enabled=state end})
UmbrellaHub.api:registerModule("World",{name="ESP",enabled=false,callback=toggleESP})

UmbrellaHub.api:registerModule("Player", {
    name = "NoClip", 
    enabled = false, 
    callback = ToggleNoClip
})

UmbrellaHub.api:registerModule("World", {
    name = "Chest ESP", 
    enabled = false, 
    callback = ToggleChestESP
})

-- ================================
-- REGISTER SETTINGS
-- ================================
UmbrellaHub.api:registerSettings("Safe Mode",{
    {name="Speed Detection Bypass",type="toggle",default=true,callback=function(v) SafeModule.speedDetectionBypass=v end},
    {name="WalkSpeed Masking",type="toggle",default=true,callback=function(v) SafeModule.walkSpeedBypass=v end},
    {name="Ability Protection",type="toggle",default=true,callback=function(v) SafeModule.abilityProtection=v end},
    {name="Wait() Hook",type="toggle",default=true,callback=function(v) SafeModule.waitHook=v if v then SetupWaitHook() end end}
})

UmbrellaHub.api:registerSettings("Walkspeed",{
    {name="Walk Speed",type="slider",min=16,max=200,default=16,callback=function(v) WalkspeedModule.Speed=v end}
})

UmbrellaHub.api:registerSettings("Jump Boost",{
    {name="Jump Power",type="slider",min=20,max=200,default=50,callback=function(v) JumpBoostModule.Power=v end}
})

UmbrellaHub.api:registerSettings("NoClip", {
    -- –ó–¥–µ—Å—å –ø—É—Å—Ç–æ, –ª–∏–±–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–∑–¥–∞—Å—Ç toggle –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å
})

-- –£–±—Ä–∞–ª –ª–∏—à–Ω–∏–π toggle –¥–ª—è Infinity Jump (–æ–Ω —É–∂–µ —É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ –º–æ–¥—É–ª—å)
UmbrellaHub.api:registerSettings("Infinity Jump",{
    -- –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –Ω–µ –Ω—É–∂–Ω—ã, —Ç–∞–∫ –∫–∞–∫ –º–æ–¥—É–ª—å —Å–∞–º –ø–æ —Å–µ–±–µ toggle
})

UmbrellaHub.api:registerSettings("ESP",{
    {name="Show Players",type="toggle",default=true,callback=function(val) ESP.ShowPlayers=val end},
    {name="Show Fruits",type="toggle",default=true,callback=function(val) ESP.ShowFruits=val end},
    {name="Show Names",type="toggle",default=true,callback=function(val) ESP.ShowName=val end},
    {name="Show HP",type="toggle",default=true,callback=function(val) ESP.ShowHealthBar=val end}
})

UmbrellaHub.api:registerSettings("Chest ESP", {
    {
        name = "Show Distance", 
        type = "toggle", 
        default = true, 
        callback = function(val) 
            ChestESP.ShowDistance = val 
        end
    },
    {
        name = "Max Distance", 
        type = "slider", 
        min = 100, 
        max = 2000, 
        default = 500, 
        callback = function(val) 
            ChestESP.MaxDistance = val 
        end
    },
    {
        name = "Max Scale", 
        type = "slider", 
        min = 1, 
        max = 5, 
        default = 3, 
        callback = function(val) 
            ChestESP.MaxScale = val 
        end
    },
    {
        name = "Text Size", 
        type = "slider", 
        min = 10, 
        max = 30, 
        default = 14, 
        callback = function(val) 
            ChestESP.BaseTextSize = val 
        end
    }
})

UmbrellaHub.init()
